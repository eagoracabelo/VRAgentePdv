package config

import InstallationConfig
import core.*
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json

@Serializable
data class MinionConfig(
    val masterIp: String,
    val minionId: String,
    val port: Int = 4506,
    val logLevel: String = "warning",
    val autoAcceptKey: Boolean = false,
    val fileClient: String = "remote",
    val pillarRoots: Map<String, List<String>> = mapOf("base" to listOf("/srv/pillar"))
)

class ConfigurationGenerator {
    private val fileUtils = FileUtils()
    private val logger = Logger

    fun generateMinionConfig(config: InstallationConfig, platform: Platform) {
        logger.info("Generating minion configuration")

        val configDir = getConfigDirectory(platform)
        val configFile = "$configDir/minion"

        val minionConfig = createMinionConfigContent(config)

        // Ensure config directory exists
        fileUtils.createDirectory(configDir)

        // Write main config file
        if (!fileUtils.writeTextFile(configFile, minionConfig)) {
            throw Exception("Failed to write minion configuration file")
        }

        // Generate additional config files
        generateLoggingConfig(config, platform)
        generatePkiConfig(config, platform)

        logger.info("Configuration files generated successfully")
    }

    private fun createMinionConfigContent(config: InstallationConfig): String {
        return """
# Salt Minion Configuration
# Generated by Salt-Minion Universal Installer

# Master configuration
master: ${config.masterIp}
master_port: ${config.port}

# Minion identity
id: ${config.minionId}

# Authentication
auto_accept_grains: False
autosign_timeout: 120

# Logging
log_level: warning
log_file: /var/log/salt/minion
key_logfile: /var/log/salt/key

# File server settings
file_client: remote
fileserver_backend:
  - roots

# Cache settings
cachedir: /var/cache/salt/minion

# Process management
multiprocessing: True
process_count_max: -1

# Network settings
tcp_keepalive: True
tcp_keepalive_idle: 300
tcp_keepalive_cnt: 3
tcp_keepalive_intvl: 30

# Security settings
verify_master_pubkey_sign: False
master_sign_pubkey: False

# Module management
enable_legacy_startup_events: False
startup_states: ''

# Pillar settings
pillar_cache: True
pillar_cache_ttl: 3600

# Mine settings
mine_enabled: True
mine_return_job: False
mine_interval: 60

# Backup configuration
backup_mode: minion

# File and directory settings
pki_dir: /etc/salt/pki/minion
sock_dir: /var/run/salt/minion

# Extension modules
extension_modules: /var/cache/salt/minion/extmods

# Custom grains (can be overridden)
grains:
  roles:
    - minion
  environment: production
  
# Enable/disable modules
disable_modules:
  - test

# State settings
state_verbose: False
state_output: changes
state_output_diff: False
        """.trimIndent()
    }

    private fun generateLoggingConfig(config: InstallationConfig, platform: Platform) {
        val logDir = getLogDirectory(platform)
        fileUtils.createDirectory(logDir)

        val loggingConfig = """
# Salt Minion Logging Configuration

[loggers]
keys=root,salt

[handlers]
keys=console,file

[formatters]
keys=generic

[logger_root]
level=WARNING
handlers=console,file

[logger_salt]
level=WARNING
handlers=console,file
qualname=salt

[handler_console]
class=StreamHandler
args=(sys.stderr,)
level=WARNING
formatter=generic

[handler_file]
class=handlers.RotatingFileHandler
args=('${logDir}/minion.log', 'a', 10485760, 5)
level=WARNING
formatter=generic

[formatter_generic]
format=%(asctime)s [%(name)-15s][%(levelname)-8s] %(message)s
datefmt=%Y-%m-%d %H:%M:%S
        """.trimIndent()

        val configDir = getConfigDirectory(platform)
        fileUtils.writeTextFile("$configDir/logging.conf", loggingConfig)
    }

    private fun generatePkiConfig(config: InstallationConfig, platform: Platform) {
        val pkiDir = getPkiDirectory(platform)
        fileUtils.createDirectory(pkiDir)

        // Create subdirectories for PKI
        fileUtils.createDirectory("$pkiDir/accepted_keys")
        fileUtils.createDirectory("$pkiDir/pending_keys")
        fileUtils.createDirectory("$pkiDir/rejected_keys")
    }

    suspend fun setupDirectoryStructure(platform: Platform) {
        logger.info("Setting up directory structure")

        val directories = listOf(
            getConfigDirectory(platform),
            getLogDirectory(platform),
            getCacheDirectory(platform),
            getPkiDirectory(platform),
            getRunDirectory(platform)
        )

        for (dir in directories) {
            if (!fileUtils.createDirectory(dir)) {
                logger.warn("Failed to create directory: $dir")
            }
        }

        // Set appropriate permissions (platform-specific)
        setPlatformPermissions(platform)
    }

    private suspend fun setPlatformPermissions(platform: Platform) {
        when (platform.name.lowercase()) {
            "linux", "ubuntu", "debian", "centos", "rhel" -> {
                // Set ownership and permissions for Salt directories
                val configDir = getConfigDirectory(platform)
                val logDir = getLogDirectory(platform)
                val pkiDir = getPkiDirectory(platform)

                try {
                    val processUtils = ProcessUtils()

                    // Make config directory readable by salt user
                    processUtils.executeAsRoot("chown", listOf("-R", "root:root", configDir))
                    processUtils.executeAsRoot("chmod", listOf("-R", "755", configDir))

                    // Make PKI directory secure
                    processUtils.executeAsRoot("chmod", listOf("-R", "700", pkiDir))

                    // Make log directory writable
                    processUtils.executeAsRoot("chown", listOf("-R", "root:root", logDir))
                    processUtils.executeAsRoot("chmod", listOf("-R", "755", logDir))

                } catch (e: Exception) {
                    logger.warn("Failed to set permissions: ${e.message}")
                }
            }
        }
    }

    fun getCurrentConfig(platform: Platform): MinionConfig? {
        val configFile = "${getConfigDirectory(platform)}/minion"

        return try {
            val content = fileUtils.readTextFile(configFile) ?: return null
            parseMinionConfig(content)
        } catch (e: Exception) {
            logger.error("Failed to read current config: ${e.message}")
            null
        }
    }

    private fun parseMinionConfig(content: String): MinionConfig {
        var masterIp = "127.0.0.1"
        var minionId = "unknown"
        var port = 4506
        var logLevel = "warning"

        content.split("\n").forEach { line ->
            val trimmed = line.trim()
            if (trimmed.startsWith("#") || trimmed.isEmpty()) return@forEach

            val parts = trimmed.split(":", limit = 2)
            if (parts.size == 2) {
                val key = parts[0].trim()
                val value = parts[1].trim()

                when (key) {
                    "master" -> masterIp = value
                    "id" -> minionId = value
                    "master_port" -> port = value.toIntOrNull() ?: 4506
                    "log_level" -> logLevel = value
                }
            }
        }

        return MinionConfig(
            masterIp = masterIp,
            minionId = minionId,
            port = port,
            logLevel = logLevel
        )
    }

    private fun getConfigDirectory(platform: Platform): String {
        return when (platform.name.lowercase()) {
            "windows" -> "C:\\salt\\conf"
            else -> "/etc/salt"
        }
    }

    private fun getLogDirectory(platform: Platform): String {
        return when (platform.name.lowercase()) {
            "windows" -> "C:\\salt\\var\\log\\salt"
            else -> "/var/log/salt"
        }
    }

    private fun getCacheDirectory(platform: Platform): String {
        return when (platform.name.lowercase()) {
            "windows" -> "C:\\salt\\var\\cache\\salt\\minion"
            else -> "/var/cache/salt/minion"
        }
    }

    private fun getPkiDirectory(platform: Platform): String {
        return when (platform.name.lowercase()) {
            "windows" -> "C:\\salt\\conf\\pki\\minion"
            else -> "/etc/salt/pki/minion"
        }
    }

    private fun getRunDirectory(platform: Platform): String {
        return when (platform.name.lowercase()) {
            "windows" -> "C:\\salt\\var\\run\\salt\\minion"
            else -> "/var/run/salt/minion"
        }
    }
}